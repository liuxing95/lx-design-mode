# 享元模式

## 1.概念 
享元模式（Flyweight Pattern）运用共享技术来有效的支持大量细粒度对象的复用，以减少创建的对象的数量。  享元模式的主要思想是共享细粒度对象，也就是说如果系统中存在多个相同的对象，那么只需要共享一份就可以了，不必每个都去实例化每一个对象，这样来精简内存资源，提升性能和效率


在类似场景中，这些例子有以下特点：
1. 目标对象具有一些共同的状态，比如驾考考生考的是自动档还是手动档，四六级考生考的是四级还是六级；
2. 这些共同的状态所对应的对象，可以被共享出来；


## 2.享元模式的改进


在原型链继承和组合继承中，子类通过原型 prototype 来复用父类的方法和属性，如果子类实例每次都创建新的方法与属性，那么在子类实例很多的情况下，内存中就存在有很多重复的方法和属性，即使这些方法和属性完全一样，因此这部分内存完全可以通过复用来优化，这也是享元模式的思想。



传统的享元模式是将目标对象的状态区分为内部状态和外部状态，内部状态相同的对象可以被共享出来指向同一个内部状态。正如之前举的驾考和四六级考试的例子中，自动档还是手动档、四级还是六级，就属于驾考考生、四六级考生中的内部状态，对应的驾考车、四六级考场就是可以被共享的对象。而考生的年龄、姓名、籍贯等就属于外部状态，一般没有被共享出来的价值。

<img src="https://cdn.nlark.com/yuque/0/2019/jpeg/140909/1573966684222-74ad4d07-da96-49f0-9293-d8eb1434c89e.jpeg">


享元模式的主要思想是细粒度对象的共享和复用  

因此对之前的驾考例子，我们可以继续改进一下：  

1.  如果某考生正在使用一辆驾考车，那么这辆驾考车的状态就是被占用，其他考生只能选择剩下未被占用状态的驾考车；
2.  如果某考生对驾考车的使用完毕，那么将驾考车开回考点，驾考车的状态改为未被占用，供给其他考生使用；
3.  如果所有驾考车都被占用，那么其他考生只能等待正在使用驾考车的考生使用完毕，直到有驾考车的状态变为未被占用；
4.  组织单位可以根据考生数量多准备几辆驾考车，比如手动档考生比较多，那么手动档驾考车就应该比自动档驾考车多准备几辆；

我们可以简单实现一下

代码可见 `Flyweight2.ts`


## 3. 资源池
上面这种改进模式 一般叫做 资源池 （Resource Pool） 或者叫对象池。  
资源池一般维护一个装载对象的池子 封装有获取 释放资源的方法 当需要对象的时候 直接从资源中获取 使用完毕之后 释放资源等待下次被获取

### 3.1 线程池

以 Node.js 中的线程池为例，Node.js 的 JavaScript 引擎是执行在单线程中的，启动的时候会新建 4 个线程放到线程池中，当遇到一些异步 I/O 操作（比如文件异步读写、DNS 查询等）或者一些 CPU 密集的操作（Crypto、Zlib 模块等）的时候，会在线程池中拿出一个线程去执行。如果有需要，线程池会按需创建新的线程。
线程池在整个 Node.js 事件循环中的位置可以参照下图：

<img src="https://cdn.nlark.com/yuque/0/2019/jpeg/140909/1573966684285-20d6db9a-2a6e-4669-a9f8-4767280b5326.jpeg?x-oss-process=image%2Fresize%2Cw_746">

上面这个图就是Node.js 的事件循环（Event Loop）机制：

1.  所有任务都在主线程上执行 形成执行栈（Execution Context Stack）；
2.  主线程之外维护一个 任务队列（Task Queue） 接到请求时将请求作为一个任务放入到这个队列中，然后继续接受其他请求
3.  一旦执行栈中的任务执行完毕， 主线程空闲时，主线程读取任务队列中的任务， 检查队列中是否有要处理的事情，这时要分两种情况： 如果是非I/O任务 就亲自处理 并通过回调函数返回到上层调用； 如果是I/O任务 将传入的参数和回调函数封装程请求对象， 并将这个请求对象推入线程池 等待执行，主线程读取下一个队列的任务，以此类推处理完成队列中的任务
4.  线程池当线程可用时，取出请求对象执行 I/O 操作，任务完成以后归还线程，并把这个完成的事件放到任务队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用


## 3.2 连接池

我们知道对数据库进行操作需要先创建一个数据库连接对象，然后通过创建好的数据库连接来对数据库进行 CRUD（增删改查）操作。如果访问量不大，对数据库的 CRUD 操作就不多，每次访问都创建连接并在使用完销毁连接就没什么，但是如果访问量比较多，并发的要求比较高时，频繁创建和销毁连接就比较消耗资源了。

这时，可以不销毁连接，一直使用已创建的连接，就可以避免频繁创建销毁连接的损耗了。但是有个问题，一个连接同一时间只能做一件事，某使用者（一般是线程）正在使用时，其他使用者就不可以使用了，所以如果只创建一个不关闭的连接显然不符合要求，我们需要创建多个不关闭的连接。


这就是连接池的来源，创建多个数据库连接，当有调用的时候直接在创建好的连接中拿出来使用，使用完毕之后将连接放回去供其他调用者使用。
我们以 Node.js 中 mysql 模块的连接池应用为例，看看后端一般是如何使用数据库连接池的。在 Node.js 中使用 mysql 创建单个连接，一般这样使用：

```js
var mysql = require('mysql');
var connection = mysql.createConnection({     // 创建数据库连接
    host: 'localhost',
    user: 'root',         // 用户名
    password: '123456',   // 密码
    database: 'db',       // 指定数据库
    port: '3306'          // 端口号
})
// 连接回调，在回调中增删改查
connection.connect(...)
// 关闭连接
connection.end(...)
```
在 Node.js 中使用 mysql 模块的连接池创建连接：

```js
var mysql = require('mysql')
var pool = mysql.createPool({     // 创建数据库连接池
    host: 'localhost',
    user: 'root',         // 用户名
    password: '123456',   // 密码
    database: 'db',       // 制定数据库
    port: '3306'          // 端口号
})
// 从连接池中获取一个连接，进行增删改查
pool.getConnection(function(err, connection) {
    // ... 数据库操作
    connection.release()  // 将连接释放回连接池中
})
// 关闭连接池
pool.end()
```
一般连接池在初始化的时候 都会自动打开n个连接， 称为`连接预热`  
如果这 n 个连接都被使用了，再从连接池中请求新的连接时，会动态地隐式创建额外连接，即`自动扩容`。  
如果扩容后的连接池一段时间后有不少连接没有被调用，则`自动缩容`，适当释放空闲连接，增加连接池中连接的使用效率。  
在连接失效的时候，自动`抛弃无效连接`。  
在系统关闭的时候，自动`释放所有连接`。



## 4. 享元模式的优缺点
享元模式的优点：
1. 由于减少了系统中的对象数量，提高了程序运行效率和性能，精简了内存占用，加快运行速度；
2. 外部状态相对独立，不会影响到内部状态，所以享元对象能够在不同的环境被共享；
享元模式的缺点：
1. 引入了共享对象，使对象结构变得复杂；
2. 共享对象的创建、销毁等需要维护，带来额外的复杂度（如果需要把共享对象维护起来的话）；