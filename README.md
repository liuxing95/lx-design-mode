# 设计模式

## 1， 创建型

### 一 单例模式

1. Singleton: 特定类 这是我们需要访问的类 访问的要拿到的是他们的实例
2. instance： 单例 这是特定类的实例 特定类一个会提供 getInstace 方法 来获取该单例
3. getInstance ：获取单例的方法，或者直接由 new 操作符获取


这里有几个实现点要关注一下：
1. 访问时始终返回的是同一个实例；
2. 自行实例化，无论是一开始加载的时候就创建好，还是在第一次被访问时；
3. 一般还会提供一个 getInstance 静态方法用来获取它的实例；



### 二 工厂模式

#### 简单工厂模式
工厂模式 （Factory Pattern），根据不同的输入返回不同类的实例，一般用来创建`同一类对象`。工厂方式的主要思想是将对象的创建（使用者调用new）与对象（类的定义）的实现分离。

<img src="https://cdn.nlark.com/yuque/0/2020/png/140909/1587000379376-192a31f3-4e50-44a4-a60f-aa5ec1e5693a.png?x-oss-process=image%2Fresize%2Cw_746">

<b>工厂模式的使用场景</b>
1. 对象的创建比较复杂，而访问者无需知道创建的具体流程；
2. 处理大量具有相同属性的小对象；


#### 抽象工厂模式
抽象工厂（Abstract Factory）： 通过对类的工厂抽象使其业务用于对产品类簇的创建，而不是负责创建某一类产品的实例。  

关键在于使用抽象类制定了实例的结构 调用者直接面向实例的结构编程，从实例的具体实现中解耦。  

抽象模式的优点：抽象产品类将产品的结构抽象出来，访问者不需要知道产品的具体实现，只需要面向产品的结构编程即可，从产品的具体实现中解耦；

<b>工厂模式和抽象工厂模式的区别:</b>
1.  工厂模式 主要关注单独的产品实例的创建；
2.  抽象工厂模式 主要关注产品类簇实例的创建，如果产品类簇只有一个产品，那么这时的抽象工厂模式就退化为工厂模式了；



### 三 建造者模式
建造者模式（Builder Pattern）又称为 生成器模式 分布构建一个复杂对象 并允许按步骤构造。  

同样的构建过程可以采用不同的标示 将一个复杂对象的构建层与其表示层分离  


在工厂模式中，创建的结果都是一个完整的个体，我们对创建的过程并不关心，只需了解创建的结果。而在建造者模式中，我们关心的是对象的创建过程，因此我们通常将创建的复杂对象的模块化，使得被创建的对象的每一个子模块都可以得到高质量的复用，当然在灵活的 JavaScript 中我们可以有更灵活的实现。

主要有以下几个概念  
1.  Director： 指挥者 调用构造者的部件具体实现进行部件装配
2.  Builder： 构造者  含有不同部件的生产方式给指挥者调用，是部件真正的生产者，但没有部件的装配流程
3.  Product： 产品 要返回给访问者的复杂对象  

<img src="https://cdn.nlark.com/yuque/0/2020/png/140909/1587001952872-c9fee538-17eb-4424-a549-3dea9c64e2a9.png?x-oss-process=image%2Fresize%2Cw_746" />

建造者模式的优点：
1.  使用建造者模式可以使产品的构建流程和产品的表现分离， 也就是将产品的创建算法和产品的实现隔离 访问者不必知道产品部件的细节
2.  扩展方便 如果希望生产一个装配顺序或方式不同的新产品，那么直接新建一个指挥者即可，不用修改既有代码，符合开闭原则；
3.  更好的复用性，建造者模式将产品的创建算法和产品组成的实现分离，所以`产品创建的算法可以复用`，产品部件的`实现逻辑也可以复用`，带来很大的灵活性；


建造者模式的缺点：
1. 建造者模式一般适用于产品之间组成部件类似的情况，如果产品之间差异性很大、复用性不高，那么不要使用建造者模式；
2. 实例的创建增加了许多额外的结构，无疑增加了许多复杂度，如果对象粒度不大，那么我们最好直接创建对象；


### 四 原型模式