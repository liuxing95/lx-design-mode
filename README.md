# 设计模式

## 1， 创建型

### 1.1 单例模式 (singleton)
### 1.2 工厂模式
#### 简单工厂模式 (factory )
#### 抽象工厂模式 (Abstract-Factory)

### 1.3 建造者模式  (Builder)

## 2， 结构型

### 2.1 代理模式 (Proxy)
### 2.2桥接模式
桥接模式（Bridge Pattern）又称为桥梁模式，将抽象部分与它的实现部分分离，使他们都可以独立地变化。使用组合关系代替继承关系，降低抽象和实现两个可变维度的耦合度。  

使用场景的特点  
1.  将抽象和实现分离，互相独立互不影响
2.  产品有多个维度（部件）， 每个维度都可以独立变化（实例化部分）

桥接模式的原理
1.  Product： 产品，由多个独立部件组成的产品；
2.  Component： 部件，组成产品的部件类；
3.  Instance： 部件类的实例；

桥接的核心就是Component，Component是产品和部件连接在一起的桥梁，桥接函数，用户只要给桥接函数传递参数即可，根据不同的参数，生产不同的部件实例，可以达到复用的效果，并且解耦产品和部件

概略图如下

<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/140909/1587017079409-6bb00212-e290-4c2d-8751-fc76a1ec7c4d.jpeg" />



### 2.3装饰器模式
装饰者模式（Decorator Pattern）又称为 装饰器模式，在不改变原对象的基础上，通过对其添加属性或方法来进行包装拓展，使得原有对象可以动态具有更多功能  

本质是功能动态组合，即动态的给一个对象添加额外的指责，就增加功能角度来看，使用装饰者模式比用继承更为灵活。  

好处是有效的把对象的核心职责和装饰功能区分开，并且通过动态增删装饰去除目标对象中重复的装饰逻辑

场景特性：
1.  装饰不影响原有的功能 原有功能可以照常使用
2.  装饰可以增加多个 共同给目标对象添加额外功能

原理图如下  


<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/140909/1587014628905-59262c8e-1fff-4037-9795-6c82a83b5c09.jpeg"/>


<b>装饰者模式的优点：</b>
1.  我们经常使用继承的方式来实现功能的扩展，但这样会给系统中带来很多的子类和复杂的继承关系，装饰者模式允许用户在不引起子类数量暴增的前提下`动态地修饰对象`，添加功能，装饰者和被装饰者之间松耦合，可维护性好；
2.  被装饰者可以使用装饰者动态地增加和撤销功能，可以在运行时选择不同的装饰器，实现不同的功能，灵活性好；
3.  装饰者模式把一系列复杂的功能分散到每个装饰器当中，一般一个装饰器只实现一个功能，可以给一个对象增加多个同样的装饰器，也可以把一个装饰器用来装饰不同的对象，有利于装饰器功能的复用；
4.  可以通过选择不同的装饰者的组合，创造不同行为和功能的结合体，原有对象的代码无须改变，就可以使得原有对象的功能变得更强大和更多样化，符合开闭原则；



装饰者模式的缺点：

1.  使用装饰者模式时会产生很多细粒度的装饰者对象，这些装饰者对象由于接口和功能的多样化导致系统复杂度增加，功能越复杂，需要的细粒度对象越多；
2.  由于更大的灵活性，也就更容易出错，特别是对于多级装饰的场景，错误定位会更加繁琐


### 2.4 适配器模式 (Adapter)
### 2.5 组合模式 （Composite）
### 2.6 享元模式 (Flyweight)
## 三， 行为型

<h3>创建型设计模式主要解决“对象的创建”问题 结构型设计模式主要解决“类或对象的组合或封装”问题，那行为型设计模式“类或对象之间的交互”的问题</h3>

### 3.1 观察者模式
观察者模式（Observer Design Pattern）也被称为发布订阅模式（Publish-Subscribe Design Pattern）在对象之间定义一个一对多的依赖，当一个对象状态改变的时候 所有依赖的对象都会自动收到通知

<b>主要概念如下</b>

1.  Publisher ： 发布者， 当消息发生时负责通知对应订阅者
2.  Subscriber ： 订阅者，当消息发生时被通知的对象
3.  SubscriberMap ：持有不同type的数组， 存储所有订阅者的数组
4.  type ： 消息类型 订阅者可以订阅的不用消息类型
5.  subscribe ： 该方法为订阅者添加到 SubscriberMap 中对应的数组中
6.  unSubscribe: 该方法为在 SubscriberMap 中删除订阅者
7.  notify : 该方法遍历通知 SubscriberMap 中对应 type 的每个订阅者


<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/140909/1587018120750-718be048-0b02-4a30-9feb-cdf31cea222c.jpeg?x-oss-process=image%2Fresize%2Cw_746" />


<b>发布-订阅模式的优缺点</b>
解耦：

1.  时间上的解耦： 注册的订阅行为由消息的发布方来决定何时调用，订阅者不用持续关注，当消息发生时发布者会负责通知
2.  对象上的解耦： 发布者不用提前知道消息的接受者是谁，发布者只需要遍历处理所有订阅该消息类型的订阅者发送消息即可（迭代器模式），由此解耦了发布者和订阅者之间的联系，互不持有， 都依赖于抽象， 不再依赖于具体



### 3.2 模板模式
模板模式， 全称是 模版方法设计模式  

模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下， 重新定义算法中的某些步骤。


模板方法模式（Template Method Pattern）父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时，重新定义算法中的某些实现步骤。模板方法模式的关键是`算法步骤的骨架和具体实现分离`。

概念：

1.  AbstractClass: 抽象父类 把一些共用的方法提取出来， 把可变的方法变为抽象类，最重要的方法是把算法骨架抽象出来为模板方法
2.  templateMethod: 模板方法 固定了希望执行的算法骨架
3.  ConcreteClass： 子类，实现抽象父类中定义的抽象方法，调用继承的模板方法时，将执行模板方法中定义的算法流程；

<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/140909/1587020521160-00a03caf-06dc-4620-9fb6-326e6dc62af9.jpeg">



### 3.3 策略模式
策略模式（Strategy Pattern）又称为 政策模式， 其定义一系列算法， 把它们一个个封装起来，并且使它们可以`互相替换`。 

封装的策略算法一般是独立的，策略模式根据输入来调整采用哪个算法。关键是策略的实现和使用分离。

概念如下：

1.  Context： 封装上下文，根据需要调用需要的策略， 屏蔽外界对策略的直接调用， 只对外提供一个接口，根据需要调用对应的策略
2.  Strategy ：策略，含有具体的算法，其方法的外观相同，因此可以互相代替；
3.  StrategyMap ：所有策略的合集，供封装上下文调用；


<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/140909/1587021174368-57ffea64-c916-4e2d-bcab-f701ef73f7dc.jpeg?x-oss-process=image%2Fresize%2Cw_746" />


策略模式的适用场景

1.  多个算法只在行为上稍有不同的场景，这时可以使用策略模式来动态选择算法；
2.  算法需要自由切换的场景；
3.  有时需要多重条件判断，那么可以使用策略模式来规避多重条件判断的情况；



### 3.4 职责链模式

### 3.5 状态模式


### 3.6 迭代器模式

### 3.7 访问器模式

### 3.8 备忘录模式

### 3.9 命令模式

### 3.10 解释器模式

### 3.11 中介模式





# 设计原则
设计原则是指导思想，从思想上给我们指明程序设计的正确方向  

设计模式是实现手段 遵守 设计原则


## 一 单一职责原则 SRP
（Single Responsibility Principle, SRP）  
一个对象只做一件事

## 二 开放封闭原则 OCP
（Open－Close Principle, OCP）

扩展开放，对修改封闭。


## 三 最少知识原则 LKP
（Least Knowledge Principle, LKP）

一个对象应该对其他对象有最少的了解。