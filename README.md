# 设计模式

## 1， 创建型

### 1.1 单例模式
### 1.2 工厂模式
#### 简单工厂模式
#### 抽象工厂模式
抽象工厂（Abstract Factory）： 通过对类的工厂抽象使其业务用于对产品类簇的创建，而不是负责创建某一类产品的实例。  

关键在于使用抽象类制定了实例的结构 调用者直接面向实例的结构编程，从实例的具体实现中解耦。  

抽象模式的优点：抽象产品类将产品的结构抽象出来，访问者不需要知道产品的具体实现，只需要面向产品的结构编程即可，从产品的具体实现中解耦；

<b>工厂模式和抽象工厂模式的区别:</b>
1.  工厂模式 主要关注单独的产品实例的创建；
2.  抽象工厂模式 主要关注产品类簇实例的创建，如果产品类簇只有一个产品，那么这时的抽象工厂模式就退化为工厂模式了；



### 1.3 建造者模式
建造者模式（Builder Pattern）又称为 生成器模式 分布构建一个复杂对象 并允许按步骤构造。  

同样的构建过程可以采用不同的标示 将一个复杂对象的构建层与其表示层分离  


在工厂模式中，创建的结果都是一个完整的个体，我们对创建的过程并不关心，只需了解创建的结果。而在建造者模式中，我们关心的是对象的创建过程，因此我们通常将创建的复杂对象的模块化，使得被创建的对象的每一个子模块都可以得到高质量的复用，当然在灵活的 JavaScript 中我们可以有更灵活的实现。

主要有以下几个概念  
1.  Director： 指挥者 调用构造者的部件具体实现进行部件装配
2.  Builder： 构造者  含有不同部件的生产方式给指挥者调用，是部件真正的生产者，但没有部件的装配流程
3.  Product： 产品 要返回给访问者的复杂对象  

<img src="https://cdn.nlark.com/yuque/0/2020/png/140909/1587001952872-c9fee538-17eb-4424-a549-3dea9c64e2a9.png?x-oss-process=image%2Fresize%2Cw_746" />

建造者模式的优点：
1.  使用建造者模式可以使产品的构建流程和产品的表现分离， 也就是将产品的创建算法和产品的实现隔离 访问者不必知道产品部件的细节
2.  扩展方便 如果希望生产一个装配顺序或方式不同的新产品，那么直接新建一个指挥者即可，不用修改既有代码，符合开闭原则；
3.  更好的复用性，建造者模式将产品的创建算法和产品组成的实现分离，所以`产品创建的算法可以复用`，产品部件的`实现逻辑也可以复用`，带来很大的灵活性；


建造者模式的缺点：
1. 建造者模式一般适用于产品之间组成部件类似的情况，如果产品之间差异性很大、复用性不高，那么不要使用建造者模式；
2. 实例的创建增加了许多额外的结构，无疑增加了许多复杂度，如果对象粒度不大，那么我们最好直接创建对象；


### 1.4 原型模式




## 2， 结构型

### 2.1 代理模式
代理模式（Proxy Pattern）又被称为委托模式， 它为目标对象创造了一个代理模式 以控制对目标对象的访问  

代理模式把代理对象插入到访问者和目标对象之间，从而为访问者对目标对象的访问引入一定的间接性。正是这种间接性，给了代理对象很多操作空间，比如在调用目标对象前和调用后进行一些预操作和后操作，从而实现新的功能或者扩展目标的功能。


#### 正向代理
正向代理： 一般的访问流程是客户端直接向目标服务器发送请求并获取内容， 使用正向代理后，客户端改为向代理服务器发送请求，并指定目标服务器（原始服务器），然后由代理服务器和原始服务器通信，转交请求并获得的内容，再返回给客户端。正向代理隐藏了真实的客户端，为客户端收发请求，`使真实客户端对服务器不可见`


#### 反向代理
反向代理： 与一般访问流程相比，使用反向代理后，直接收到请求的服务器是代理服务器，然后将请求转发给内部网络上真正进行处理的服务器，得到的结果返回给客户端。反向代理隐藏了真实的服务器，为服务器收发请求，使真实服务器对客户端不可见。


### 2.2桥接模式
桥接模式（Bridge Pattern）又称为桥梁模式，将抽象部分与它的实现部分分离，使他们都可以独立地变化。使用组合关系代替继承关系，降低抽象和实现两个可变维度的耦合度。  

使用场景的特点  
1.  将抽象和实现分离，互相独立互不影响
2.  产品有多个维度（部件）， 每个维度都可以独立变化（实例化部分）

桥接模式的原理
1.  Product： 产品，由多个独立部件组成的产品；
2.  Component： 部件，组成产品的部件类；
3.  Instance： 部件类的实例；

桥接的核心就是Component，Component是产品和部件连接在一起的桥梁，桥接函数，用户只要给桥接函数传递参数即可，根据不同的参数，生产不同的部件实例，可以达到复用的效果，并且解耦产品和部件

概略图如下

<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/140909/1587017079409-6bb00212-e290-4c2d-8751-fc76a1ec7c4d.jpeg" />



### 2.3装饰器模式
装饰者模式（Decorator Pattern）又称为 装饰器模式，在不改变原对象的基础上，通过对其添加属性或方法来进行包装拓展，使得原有对象可以动态具有更多功能  

本质是功能动态组合，即动态的给一个对象添加额外的指责，就增加功能角度来看，使用装饰者模式比用继承更为灵活。  

好处是有效的把对象的核心职责和装饰功能区分开，并且通过动态增删装饰去除目标对象中重复的装饰逻辑

场景特性：
1.  装饰不影响原有的功能 原有功能可以照常使用
2.  装饰可以增加多个 共同给目标对象添加额外功能

原理图如下  


<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/140909/1587014628905-59262c8e-1fff-4037-9795-6c82a83b5c09.jpeg"/>


<b>装饰者模式的优点：</b>
1.  我们经常使用继承的方式来实现功能的扩展，但这样会给系统中带来很多的子类和复杂的继承关系，装饰者模式允许用户在不引起子类数量暴增的前提下`动态地修饰对象`，添加功能，装饰者和被装饰者之间松耦合，可维护性好；
2.  被装饰者可以使用装饰者动态地增加和撤销功能，可以在运行时选择不同的装饰器，实现不同的功能，灵活性好；
3.  装饰者模式把一系列复杂的功能分散到每个装饰器当中，一般一个装饰器只实现一个功能，可以给一个对象增加多个同样的装饰器，也可以把一个装饰器用来装饰不同的对象，有利于装饰器功能的复用；
4.  可以通过选择不同的装饰者的组合，创造不同行为和功能的结合体，原有对象的代码无须改变，就可以使得原有对象的功能变得更强大和更多样化，符合开闭原则；



装饰者模式的缺点：

1.  使用装饰者模式时会产生很多细粒度的装饰者对象，这些装饰者对象由于接口和功能的多样化导致系统复杂度增加，功能越复杂，需要的细粒度对象越多；
2.  由于更大的灵活性，也就更容易出错，特别是对于多级装饰的场景，错误定位会更加繁琐


### 2.4 适配器模式
适配器模式（Adapter Pattern） 又称为 包装器模式 将一个类（对象）的接口（方法， 属性）转化为用户需要的另一个接口，解决类（对象）之间接口不兼容的问题。


主要功能是进行转换匹配， 目的是复用已有的功能 而不是实现新的接口。 也就是说， 访问者需要的功能应该是已经实现好了的，不需要再去实现功能，适配器模式主要是负责把不兼容的接口转换成访问者期望的格式而已



访问者需要目标对象的某个功能，但是这个对象的接口不是自己期望的，那么通过适配器模式对现有对象的接口进行包装，来获得自己需要的接口格式。


<img src="https://cdn.nlark.com/yuque/0/2020/png/140909/1587007619844-15731868-60b3-47ce-86ca-54b8d650d2d0.png?x-oss-process=image%2Fresize%2Cw_746" />

<br />


### 2.5 组合模式
组合模式（Composite Pattern）又叫 整体-部分模式，它允许你将对象组合成树状结构来表现 整体-部分 层次结构 让使用者可以以一致的方式处理组合对象以及部分对象

使用场景特点
1.  结构呈整体-部分的树形关系，整体部分一般称为组合对象，组合对象下还可以有组合对象和叶对象；
2.  组合对象和叶对象有一致的接口和数据结构，以保证操作一致；
3.  请求从树的最顶端往下传递，如果当前处理请求的对象是叶对象，叶对象自身会对请求作出相应的处理；如果当前处理的是组合对象，则遍历其下的子节点（叶对象），将请求继续传递给这些子节点；




### 2.6 享元模式
享元模式（Flyweight Pattern）运用共享技术来有效的支持大量细粒度对象的复用，以减少创建的对象的数量。  享元模式的主要思想是共享细粒度对象，也就是说如果系统中存在多个相同的对象，那么只需要共享一份就可以了，不必每个都去实例化每一个对象，这样来精简内存资源，提升性能和效率

使用场景的特点
1.  目标对象具有一些共同的状态
2.  这些共享的状态所对应的对象 可以被共享出来

<b>享元模式的思想</b>

在原型链继承和组合继承中，子类通过原型 prototype 来复用父类的方法和属性，如果子类实例每次都创建新的方法与属性，那么在子类实例很多的情况下，内存中就存在有很多重复的方法和属性，即使这些方法和属性完全一样，因此这部分内存完全可以通过复用来优化，这也是享元模式的思想。



## 三， 行为型

<h3>创建型设计模式主要解决“对象的创建”问题 结构型设计模式主要解决“类或对象的组合或封装”问题，那行为型设计模式“类或对象之间的交互”的问题</h3>

### 3.1 观察者模式
观察者模式（Observer Design Pattern）也被称为发布订阅模式（Publish-Subscribe Design Pattern）在对象之间定义一个一对多的依赖，当一个对象状态改变的时候 所有依赖的对象都会自动收到通知

<b>主要概念如下</b>

1.  Publisher ： 发布者， 当消息发生时负责通知对应订阅者
2.  Subscriber ： 订阅者，当消息发生时被通知的对象
3.  SubscriberMap ：持有不同type的数组， 存储所有订阅者的数组
4.  type ： 消息类型 订阅者可以订阅的不用消息类型
5.  subscribe ： 该方法为订阅者添加到 SubscriberMap 中对应的数组中
6.  unSubscribe: 该方法为在 SubscriberMap 中删除订阅者
7.  notify : 该方法遍历通知 SubscriberMap 中对应 type 的每个订阅者


<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/140909/1587018120750-718be048-0b02-4a30-9feb-cdf31cea222c.jpeg?x-oss-process=image%2Fresize%2Cw_746" />


<b>发布-订阅模式的优缺点</b>
解耦：

1.  时间上的解耦： 注册的订阅行为由消息的发布方来决定何时调用，订阅者不用持续关注，当消息发生时发布者会负责通知
2.  对象上的解耦： 发布者不用提前知道消息的接受者是谁，发布者只需要遍历处理所有订阅该消息类型的订阅者发送消息即可（迭代器模式），由此解耦了发布者和订阅者之间的联系，互不持有， 都依赖于抽象， 不再依赖于具体



### 3.2 模板模式
模板模式， 全称是 模版方法设计模式  

模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下， 重新定义算法中的某些步骤。


模板方法模式（Template Method Pattern）父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时，重新定义算法中的某些实现步骤。模板方法模式的关键是`算法步骤的骨架和具体实现分离`。

概念：

1.  AbstractClass: 抽象父类 把一些共用的方法提取出来， 把可变的方法变为抽象类，最重要的方法是把算法骨架抽象出来为模板方法
2.  templateMethod: 模板方法 固定了希望执行的算法骨架
3.  ConcreteClass： 子类，实现抽象父类中定义的抽象方法，调用继承的模板方法时，将执行模板方法中定义的算法流程；

<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/140909/1587020521160-00a03caf-06dc-4620-9fb6-326e6dc62af9.jpeg">



### 3.3 策略模式
策略模式（Strategy Pattern）又称为 政策模式， 其定义一系列算法， 把它们一个个封装起来，并且使它们可以`互相替换`。 

封装的策略算法一般是独立的，策略模式根据输入来调整采用哪个算法。关键是策略的实现和使用分离。

概念如下：

1.  Context： 封装上下文，根据需要调用需要的策略， 屏蔽外界对策略的直接调用， 只对外提供一个接口，根据需要调用对应的策略
2.  Strategy ：策略，含有具体的算法，其方法的外观相同，因此可以互相代替；
3.  StrategyMap ：所有策略的合集，供封装上下文调用；


<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/140909/1587021174368-57ffea64-c916-4e2d-bcab-f701ef73f7dc.jpeg?x-oss-process=image%2Fresize%2Cw_746" />


策略模式的适用场景

1.  多个算法只在行为上稍有不同的场景，这时可以使用策略模式来动态选择算法；
2.  算法需要自由切换的场景；
3.  有时需要多重条件判断，那么可以使用策略模式来规避多重条件判断的情况；



### 3.4 职责链模式

### 3.5 状态模式


### 3.6 迭代器模式

### 3.7 访问器模式

### 3.8 备忘录模式

### 3.9 命令模式

### 3.10 解释器模式

### 3.11 中介模式





# 设计原则
设计原则是指导思想，从思想上给我们指明程序设计的正确方向  

设计模式是实现手段 遵守 设计原则


## 一 单一职责原则 SRP
（Single Responsibility Principle, SRP）  
一个对象只做一件事

## 二 开放封闭原则 OCP
（Open－Close Principle, OCP）

扩展开放，对修改封闭。


## 三 最少知识原则 LKP
（Least Knowledge Principle, LKP）

一个对象应该对其他对象有最少的了解。