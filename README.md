# 设计模式

## 1， 创建型

### 1.1 单例模式

1. Singleton: 特定类 这是我们需要访问的类 访问的要拿到的是他们的实例
2. instance： 单例 这是特定类的实例 特定类一个会提供 getInstace 方法 来获取该单例
3. getInstance ：获取单例的方法，或者直接由 new 操作符获取


这里有几个实现点要关注一下：
1. 访问时始终返回的是同一个实例；
2. 自行实例化，无论是一开始加载的时候就创建好，还是在第一次被访问时；
3. 一般还会提供一个 getInstance 静态方法用来获取它的实例；



### 1.2 工厂模式

#### 简单工厂模式
工厂模式 （Factory Pattern），根据不同的输入返回不同类的实例，一般用来创建`同一类对象`。工厂方式的主要思想是将对象的创建（使用者调用new）与对象（类的定义）的实现分离。

<img src="https://cdn.nlark.com/yuque/0/2020/png/140909/1587000379376-192a31f3-4e50-44a4-a60f-aa5ec1e5693a.png?x-oss-process=image%2Fresize%2Cw_746">

<b>工厂模式的使用场景</b>
1. 对象的创建比较复杂，而访问者无需知道创建的具体流程；
2. 处理大量具有相同属性的小对象；


#### 抽象工厂模式
抽象工厂（Abstract Factory）： 通过对类的工厂抽象使其业务用于对产品类簇的创建，而不是负责创建某一类产品的实例。  

关键在于使用抽象类制定了实例的结构 调用者直接面向实例的结构编程，从实例的具体实现中解耦。  

抽象模式的优点：抽象产品类将产品的结构抽象出来，访问者不需要知道产品的具体实现，只需要面向产品的结构编程即可，从产品的具体实现中解耦；

<b>工厂模式和抽象工厂模式的区别:</b>
1.  工厂模式 主要关注单独的产品实例的创建；
2.  抽象工厂模式 主要关注产品类簇实例的创建，如果产品类簇只有一个产品，那么这时的抽象工厂模式就退化为工厂模式了；



### 1.3 建造者模式
建造者模式（Builder Pattern）又称为 生成器模式 分布构建一个复杂对象 并允许按步骤构造。  

同样的构建过程可以采用不同的标示 将一个复杂对象的构建层与其表示层分离  


在工厂模式中，创建的结果都是一个完整的个体，我们对创建的过程并不关心，只需了解创建的结果。而在建造者模式中，我们关心的是对象的创建过程，因此我们通常将创建的复杂对象的模块化，使得被创建的对象的每一个子模块都可以得到高质量的复用，当然在灵活的 JavaScript 中我们可以有更灵活的实现。

主要有以下几个概念  
1.  Director： 指挥者 调用构造者的部件具体实现进行部件装配
2.  Builder： 构造者  含有不同部件的生产方式给指挥者调用，是部件真正的生产者，但没有部件的装配流程
3.  Product： 产品 要返回给访问者的复杂对象  

<img src="https://cdn.nlark.com/yuque/0/2020/png/140909/1587001952872-c9fee538-17eb-4424-a549-3dea9c64e2a9.png?x-oss-process=image%2Fresize%2Cw_746" />

建造者模式的优点：
1.  使用建造者模式可以使产品的构建流程和产品的表现分离， 也就是将产品的创建算法和产品的实现隔离 访问者不必知道产品部件的细节
2.  扩展方便 如果希望生产一个装配顺序或方式不同的新产品，那么直接新建一个指挥者即可，不用修改既有代码，符合开闭原则；
3.  更好的复用性，建造者模式将产品的创建算法和产品组成的实现分离，所以`产品创建的算法可以复用`，产品部件的`实现逻辑也可以复用`，带来很大的灵活性；


建造者模式的缺点：
1. 建造者模式一般适用于产品之间组成部件类似的情况，如果产品之间差异性很大、复用性不高，那么不要使用建造者模式；
2. 实例的创建增加了许多额外的结构，无疑增加了许多复杂度，如果对象粒度不大，那么我们最好直接创建对象；


### 1.4 原型模式




## 2， 结构型

### 2.1 代理模式
代理模式（Proxy Pattern）又被称为委托模式， 它为目标对象创造了一个代理模式 以控制对目标对象的访问  

代理模式把代理对象插入到访问者和目标对象之间，从而为访问者对目标对象的访问引入一定的间接性。正是这种间接性，给了代理对象很多操作空间，比如在调用目标对象前和调用后进行一些预操作和后操作，从而实现新的功能或者扩展目标的功能。


#### 正向代理
正向代理： 一般的访问流程是客户端直接向目标服务器发送请求并获取内容， 使用正向代理后，客户端改为向代理服务器发送请求，并指定目标服务器（原始服务器），然后由代理服务器和原始服务器通信，转交请求并获得的内容，再返回给客户端。正向代理隐藏了真实的客户端，为客户端收发请求，`使真实客户端对服务器不可见`


#### 反向代理
反向代理： 与一般访问流程相比，使用反向代理后，直接收到请求的服务器是代理服务器，然后将请求转发给内部网络上真正进行处理的服务器，得到的结果返回给客户端。反向代理隐藏了真实的服务器，为服务器收发请求，使真实服务器对客户端不可见。


### 2.2桥接模式
桥接模式（Bridge Pattern）又称为桥梁模式，将抽象部分与它的实现部分分离，使他们都可以独立地变化。使用组合关系代替继承关系，降低抽象和实现两个可变维度的耦合度。  

使用场景的特点  
1.  将抽象和实现分离，互相独立互不影响
2.  产品有多个维度（部件）， 每个维度都可以独立变化（实例化部分）

桥接模式的原理
1.  Product： 产品，由多个独立部件组成的产品；
2.  Component： 部件，组成产品的部件类；
3.  Instance： 部件类的实例；

桥接的核心就是Component，Component是产品和部件连接在一起的桥梁，桥接函数，用户只要给桥接函数传递参数即可，根据不同的参数，生产不同的部件实例，可以达到复用的效果，并且解耦产品和部件

概略图如下

<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/140909/1587017079409-6bb00212-e290-4c2d-8751-fc76a1ec7c4d.jpeg" />



### 2.3装饰器模式
装饰者模式（Decorator Pattern）又称为 装饰器模式，在不改变原对象的基础上，通过对其添加属性或方法来进行包装拓展，使得原有对象可以动态具有更多功能  

本质是功能动态组合，即动态的给一个对象添加额外的指责，就增加功能角度来看，使用装饰者模式比用继承更为灵活。  

好处是有效的把对象的核心职责和装饰功能区分开，并且通过动态增删装饰去除目标对象中重复的装饰逻辑

场景特性：
1.  装饰不影响原有的功能 原有功能可以照常使用
2.  装饰可以增加多个 共同给目标对象添加额外功能

原理图如下  


<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/140909/1587014628905-59262c8e-1fff-4037-9795-6c82a83b5c09.jpeg"/>


<b>装饰者模式的优点：</b>
1.  我们经常使用继承的方式来实现功能的扩展，但这样会给系统中带来很多的子类和复杂的继承关系，装饰者模式允许用户在不引起子类数量暴增的前提下`动态地修饰对象`，添加功能，装饰者和被装饰者之间松耦合，可维护性好；
2.  被装饰者可以使用装饰者动态地增加和撤销功能，可以在运行时选择不同的装饰器，实现不同的功能，灵活性好；
3.  装饰者模式把一系列复杂的功能分散到每个装饰器当中，一般一个装饰器只实现一个功能，可以给一个对象增加多个同样的装饰器，也可以把一个装饰器用来装饰不同的对象，有利于装饰器功能的复用；
4.  可以通过选择不同的装饰者的组合，创造不同行为和功能的结合体，原有对象的代码无须改变，就可以使得原有对象的功能变得更强大和更多样化，符合开闭原则；



装饰者模式的缺点：

1.  使用装饰者模式时会产生很多细粒度的装饰者对象，这些装饰者对象由于接口和功能的多样化导致系统复杂度增加，功能越复杂，需要的细粒度对象越多；
2.  由于更大的灵活性，也就更容易出错，特别是对于多级装饰的场景，错误定位会更加繁琐


### 2.4 适配器模式
适配器模式（Adapter Pattern） 又称为 包装器模式 将一个类（对象）的接口（方法， 属性）转化为用户需要的另一个接口，解决类（对象）之间接口不兼容的问题。


主要功能是进行转换匹配， 目的是复用已有的功能 而不是实现新的接口。 也就是说， 访问者需要的功能应该是已经实现好了的，不需要再去实现功能，适配器模式主要是负责把不兼容的接口转换成访问者期望的格式而已



访问者需要目标对象的某个功能，但是这个对象的接口不是自己期望的，那么通过适配器模式对现有对象的接口进行包装，来获得自己需要的接口格式。


<img src="https://cdn.nlark.com/yuque/0/2020/png/140909/1587007619844-15731868-60b3-47ce-86ca-54b8d650d2d0.png?x-oss-process=image%2Fresize%2Cw_746" />

<br />


### 2.5 组合模式
组合模式（Composite Pattern）又叫 整体-部分模式，它允许你将对象组合成树状结构来表现 整体-部分 层次结构 让使用者可以以一致的方式处理组合对象以及部分对象

使用场景特点
1.  结构呈整体-部分的树形关系，整体部分一般称为组合对象，组合对象下还可以有组合对象和叶对象；
2.  组合对象和叶对象有一致的接口和数据结构，以保证操作一致；
3.  请求从树的最顶端往下传递，如果当前处理请求的对象是叶对象，叶对象自身会对请求作出相应的处理；如果当前处理的是组合对象，则遍历其下的子节点（叶对象），将请求继续传递给这些子节点；




### 2.6 享元模式
享元模式（Flyweight Pattern）运用共享技术来有效的支持大量细粒度对象的复用，以减少创建的对象的数量。  享元模式的主要思想是共享细粒度对象，也就是说如果系统中存在多个相同的对象，那么只需要共享一份就可以了，不必每个都去实例化每一个对象，这样来精简内存资源，提升性能和效率

使用场景的特点
1.  目标对象具有一些共同的状态
2.  这些共享的状态所对应的对象 可以被共享出来

<b>享元模式的思想</b>

在原型链继承和组合继承中，子类通过原型 prototype 来复用父类的方法和属性，如果子类实例每次都创建新的方法与属性，那么在子类实例很多的情况下，内存中就存在有很多重复的方法和属性，即使这些方法和属性完全一样，因此这部分内存完全可以通过复用来优化，这也是享元模式的思想。
