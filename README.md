# 设计模式
## 1， 创建型
### 1.1 单例模式 (singleton)
### 1.2 工厂模式
#### 简单工厂模式 (factory )
#### 抽象工厂模式 (Abstract-Factory)
### 1.3 建造者模式  (Builder)
## 2， 结构型
### 2.1 代理模式 (Proxy)
### 2.2桥接模式（Bridge）
### 2.3装饰器模式
装饰者模式（Decorator Pattern）又称为 装饰器模式，在不改变原对象的基础上，通过对其添加属性或方法来进行包装拓展，使得原有对象可以动态具有更多功能  

本质是功能动态组合，即动态的给一个对象添加额外的指责，就增加功能角度来看，使用装饰者模式比用继承更为灵活。  

好处是有效的把对象的核心职责和装饰功能区分开，并且通过动态增删装饰去除目标对象中重复的装饰逻辑

场景特性：
1.  装饰不影响原有的功能 原有功能可以照常使用
2.  装饰可以增加多个 共同给目标对象添加额外功能

原理图如下  


<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/140909/1587014628905-59262c8e-1fff-4037-9795-6c82a83b5c09.jpeg"/>


<b>装饰者模式的优点：</b>
1.  我们经常使用继承的方式来实现功能的扩展，但这样会给系统中带来很多的子类和复杂的继承关系，装饰者模式允许用户在不引起子类数量暴增的前提下`动态地修饰对象`，添加功能，装饰者和被装饰者之间松耦合，可维护性好；
2.  被装饰者可以使用装饰者动态地增加和撤销功能，可以在运行时选择不同的装饰器，实现不同的功能，灵活性好；
3.  装饰者模式把一系列复杂的功能分散到每个装饰器当中，一般一个装饰器只实现一个功能，可以给一个对象增加多个同样的装饰器，也可以把一个装饰器用来装饰不同的对象，有利于装饰器功能的复用；
4.  可以通过选择不同的装饰者的组合，创造不同行为和功能的结合体，原有对象的代码无须改变，就可以使得原有对象的功能变得更强大和更多样化，符合开闭原则；



装饰者模式的缺点：

1.  使用装饰者模式时会产生很多细粒度的装饰者对象，这些装饰者对象由于接口和功能的多样化导致系统复杂度增加，功能越复杂，需要的细粒度对象越多；
2.  由于更大的灵活性，也就更容易出错，特别是对于多级装饰的场景，错误定位会更加繁琐


### 2.4 适配器模式 (Adapter)
### 2.5 组合模式 （Composite）
### 2.6 享元模式 (Flyweight)
## 三， 行为型

<h3>创建型设计模式主要解决“对象的创建”问题 结构型设计模式主要解决“类或对象的组合或封装”问题，那行为型设计模式“类或对象之间的交互”的问题</h3>

### 3.1 观察者模式
### 3.2 模板模式
模板模式， 全称是 模版方法设计模式  

模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下， 重新定义算法中的某些步骤。


模板方法模式（Template Method Pattern）父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时，重新定义算法中的某些实现步骤。模板方法模式的关键是`算法步骤的骨架和具体实现分离`。

概念：

1.  AbstractClass: 抽象父类 把一些共用的方法提取出来， 把可变的方法变为抽象类，最重要的方法是把算法骨架抽象出来为模板方法
2.  templateMethod: 模板方法 固定了希望执行的算法骨架
3.  ConcreteClass： 子类，实现抽象父类中定义的抽象方法，调用继承的模板方法时，将执行模板方法中定义的算法流程；

<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/140909/1587020521160-00a03caf-06dc-4620-9fb6-326e6dc62af9.jpeg">

### 3.3 策略模式
### 3.4 职责链模式
### 3.5 状态模式
### 3.6 迭代器模式
### 3.7 访问器模式
### 3.8 备忘录模式
### 3.9 命令模式
### 3.10 解释器模式
### 3.11 中介模式
# 设计原则
设计原则是指导思想，从思想上给我们指明程序设计的正确方向  

设计模式是实现手段 遵守 设计原则


## 一 单一职责原则 SRP
（Single Responsibility Principle, SRP）  
一个对象只做一件事

## 二 开放封闭原则 OCP
（Open－Close Principle, OCP）

扩展开放，对修改封闭。


## 三 最少知识原则 LKP
（Least Knowledge Principle, LKP）

一个对象应该对其他对象有最少的了解。